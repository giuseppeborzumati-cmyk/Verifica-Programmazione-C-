<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generatore Verifiche C++ per il Prof. Borzumati</title>
    <!-- Carica Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Carica la libreria jsPDF per la generazione di PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Carica la libreria JSZip per l'archiviazione ZIP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <!-- Configurazione del font per Tailwind -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc;
        }
    </style>
</head>
<body>

<div class="min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-2xl bg-white shadow-2xl rounded-xl p-8 space-y-6 border border-gray-100">
        <!-- Header dell'Applicazione -->
        <header class="text-center pb-4 border-b border-blue-100">
            <h1 class="text-3xl font-bold text-blue-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="inline w-8 h-8 mr-2 -mt-1" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><line x1="10" y1="9" x2="8" y2="9"></line></svg>
                Generatore Verifiche C++
            </h1>
            <p class="text-gray-500 mt-1">Prof. Giuseppe Borzumati - Sezione: Logica e Strutture di Controllo (Durata: 1 ora)</p>
        </header>

        <!-- Form e Input -->
        <div class="space-y-4">
            <div>
                <label for="numAlunni" class="block text-sm font-medium text-gray-700">Numero di Alunni:</label>
                <input type="number" id="numAlunni" value="5" min="1" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm transition duration-150" placeholder="Inserisci il numero di studenti">
            </div>

            <button onclick="generateTests()" id="generateBtn" class="w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-md text-sm font-medium text-white bg-green-500 hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition duration-150 transform hover:scale-[1.01]">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 01-1-1V6a1 1 0 011-1h5.172a2 2 0 011.414.586l3.656 3.656A2 2 0 0114.828 11H18a1 1 0 011 1v3a1 1 0 01-1 1h-6.172a2 2 0 01-1.414-.586l-3.656-3.656A2 2 0 015.172 9H3a1 1 0 01-1-1v-2h1a1 1 0 000-2H2a1 1 0 01-1-1V3a1 1 0 011-1h16a1 1 0 011 1v14a1 1 0 01-1 1H3zM9 9a1 1 0 001 1h6a1 1 0 100-2h-6a1 1 0 00-1 1z" clip-rule="evenodd" /></svg>
                Genera Verifiche in ZIP
            </button>

            <!-- Messaggio di Stato -->
            <div id="statusMessage" class="text-center mt-4 text-sm font-medium text-gray-600 h-6"></div>
        </div>
    </div>
</div>

<script>
    const MAX_SCORE = 100;
    const { jsPDF } = window.jspdf;

    // Struttura dei Punteggi (Pratica/Teoria/Totale) per 100 punti totali, scalari
    const scores = [
        { P: 3, T: 2, Total: 5, difficulty: 'Facile' },
        { P: 4, T: 3, Total: 7, difficulty: 'Facile' },
        { P: 5, T: 4, Total: 9, difficulty: 'Facile' },
        { P: 6, T: 4, Total: 10, difficulty: 'Facile' },
        { P: 7, T: 5, Total: 12, difficulty: 'Complicato' },
        { P: 8, T: 6, Total: 14, difficulty: 'Complicato' },
        { P: 10, T: 8, Total: 18, difficulty: 'Complicato' },
        { P: 12, T: 10, Total: 22, difficulty: 'Complicato' },
        { P: 1, T: 1, Total: 2, difficulty: 'Concettuale' },
        { P: 1, T: 1, Total: 2, difficulty: 'Impossibile (AI Check)' }
    ];

    // Mappa degli Esercizi (Tracce Lunghe e Complesse)
    const exerciseTemplates = [
        // Esercizio 1 (Facile - 5 punti): IF/ELSE, LOGICA BOOLEANA, BOOL, OPERATORI LOGICI
        { topics: ['if/else', 'bool', 'operatori logici'], trace: seed => `Analisi di Condizione Booleana: Dato un contesto in cui una variabile intera 'livello' rappresenta la difficoltà di un gioco (da 1 a 10) e una variabile booleana 'utentePro' indica se l'utente è esperto, analizza il seguente snippet C++. Indica l'output preciso per il caso in cui livello = ${seed % 6 + 1} e utentePro è vero, e il caso in cui livello = ${seed % 6 + 7} e utentePro è falso. Descrivi il ruolo dell'operatore logico OR (||) e del NOT (!):\n\n\`\`\`cpp\nint livello = ${seed % 6 + 1};\nbool utentePro = true;\nif (livello < 5 || (livello >= 8 && !utentePro))\n    std::cout << "Livello Introduttivo";\nelse\n    std::cout << "Livello Avanzato";\n\`\`\``, code_lines: 6 },
        
        // Esercizio 2 (Facile - 7 punti): VARIABILI TEMPORANEE, OPERATORI UNARI
        { topics: ['variabili temporanee', 'operatori unari'], trace: seed => `Effetti Collaterali degli Operatori Unari: In un frammento di codice che gestisce un contatore e un punteggio temporaneo, calcola il valore finale di \`contatore\` e \`punteggioTemporaneo\` se inizialmente \`contatore = ${seed % 5 + 1}\` e \`punteggioTemporaneo = ${seed % 5 + 10}\`. Spiega in dettaglio la differenza fondamentale tra l'operatore pre-incremento (\`++a\`) e post-incremento (\`a++\`) e come influenzano l'assegnazione di variabili temporanee:\n\n\`\`\`cpp\nint contatore = ${seed % 5 + 1}, punteggioTemporaneo = ${seed % 5 + 10};\npunteggioTemporaneo = contatore++;\ncontatore = ++punteggioTemporaneo;\n\`\`\``, code_lines: 5 },
        
        // Esercizio 3 (Facile - 9 punti): FOR, OPERATORI LOGICI (condizione)
        { topics: ['for', 'operatori logici'], trace: seed => `Ciclo 'for' e Condizione di Terminazione: Si vuole calcolare la somma dei numeri pari la cui radice quadrata è minore di un certo limite N. Qual è il valore finale di \`somma\` e quante iterazioni del ciclo \`for\` vengono effettivamente eseguite? Il limite N è pari a ${seed % 10 + 10}. Fai attenzione alla condizione di terminazione non standard (i * i <= N) che ottimizza il calcolo della radice quadrata e spiega il motivo di questa scelta:\n\n\`\`\`cpp\nint somma = 0;\nfor (int i = 1; i * i <= ${seed % 10 + 10}; i++) {\n    if (i % 2 == 0) {\n        somma += i;\n    }\n}\n\`\`\``, code_lines: 6 },
        
        // Esercizio 4 (Facile - 10 punti): WHILE, LOGICA BOOLEANA
        { topics: ['while', 'logica booleana'], trace: seed => `Simulazione di Logica Condizionale Composta: Prevedi l'output finale del seguente codice che utilizza una logica booleana complessa all'interno della condizione \`while\`. Le variabili iniziali sono \`a = ${seed % 5 + 2}\` e \`b = ${seed % 5 + 1}\`. Giustifica ogni iterazione e spiega in quale specifico momento la condizione \`a < ${seed % 5 + 8} && b <= a\` viene valutata come falsa, causando l'uscita dal ciclo:\n\n\`\`\`cpp\nint a = ${seed % 5 + 2}, b = ${seed % 5 + 1};\nwhile (a < ${seed % 5 + 8} && b <= a) {\n    a++;\n    b += a % 2;\n}\nstd::cout << "A: " << a << ", B: " << b;\n\`\`\``, code_lines: 7 },
        
        // Esercizio 5 (Complicato - 12 punti): DO-WHILE, OPERATORI UNARI
        { topics: ['do-while', 'if/else', 'operatori unari'], trace: seed => `Rifattorizzazione di Cicli con 'continue': Riscrivi il ciclo \`do-while\` qui sotto utilizzando un'equivalente struttura \`for\`, mantenendo la stessa logica e gli stessi effetti collaterali (incluso l'uso dell'operatore unario). Qual è il valore finale di \`contatore\` se inizia da \`${seed % 5 + 1}\` e \`limite = ${seed % 5 + 6}\`? Spiega perché la clausola \`continue\` all'interno di un ciclo è spesso considerata una pratica da evitare in codice professionale e quale alternativa con \`if/else\` è preferibile:\n\n\`\`\`cpp\nint contatore = ${seed % 5 + 1}, limite = ${seed % 5 + 6};\ndo {\n    contatore++;\n    if (contatore % 3 == 0) continue;\n} while (contatore < limite);\n\`\`\``, code_lines: 7 },
        
        // Esercizio 6 (Complicato - 14 punti): FOR, VARIABILI TEMPORANEE
        { topics: ['for', 'variabili temporanee'], trace: seed => `Implementazione con Variabili Temporanee per Sequenze: Scrivi un programma completo (con la funzione \`main\`) che, usando un ciclo \`for\`, stampi i numeri da ${seed % 5 + 5} a ${seed % 5 + 15} ma salti la stampa se il numero corrente è un numero di Fibonacci. Descrivi quali variabili temporanee devi introdurre per tenere traccia dei valori di Fibonacci (due variabili per il calcolo e una per il controllo) e giustifica la loro dichiarazione all'esterno o all'interno del ciclo. La logica deve essere efficiente e chiara.`, code_lines: 10 },
        
        // Esercizio 7 (Complicato - 18 punti): IF/ELSE, LOGICA BOOLEANA, OPERATORI LOGICI
        { topics: ['while', 'logica booleana', 'operatori logici', 'if/else'], trace: seed => `Analisi e Correzione di Errori Logici: Il seguente codice contiene una condizione booleana errata che non esegue la stampa di "OK" come ci si aspetterebbe. L'obiettivo è che \`risultato\` sia \`true\` solo se \`a\` è strettamente maggiore di 10 E \`b\` è pari. Correggi la logica booleana nell'istruzione \`if\` sapendo che \`a = ${seed % 10 + 10}\` e \`b = ${seed % 10 + 2}\`. Utilizza le Leggi di De Morgan (o una spiegazione logica equivalente) per spiegare perché la negazione attuale è errata e come la tua correzione la rende intuitiva:\n\n\`\`\`cpp\nint a = ${seed % 10 + 10}, b = ${seed % 10 + 2};\nbool risultato = (a <= 10) || (b % 2 != 0);\nif (!risultato)\n    std::cout << "OK";\nelse\n    std::cout << "ERRORE";\n\`\`\``, code_lines: 6 },
        
        // Esercizio 8 (Complicato - 22 punti): FOR, VARIABILI TEMPORANEE
        { topics: ['for', 'overflow', 'variabili temporanee'], trace: seed => `Comportamento di Overflow e Limiti di Tipi: Considera un ciclo \`for\` che utilizza una variabile \`int\` standard a 32 bit (valore massimo circa 2.147 miliardi). Quale sarà l'output o il comportamento del programma se il ciclo viene eseguito a partire dal valore 2147483640 e l'incremento dovesse portarlo oltre il limite massimo? Spiega in profondità il concetto di overflow in un ciclo e identifica precisamente quale variabile temporanea o contatore del ciclo può causare un potenziale errore di runtime non gestito:\n\n\`\`\`cpp\nfor (int i = 2147483640; i < 2147483647 + ${seed % 5 + 1}; i++) {\n    //...\n}\n\`\`\``, code_lines: 5 },

        // Esercizio 9 (Concettuale - 2 punti): Concettuale su WHILE, FOR, DO-WHILE, VARIABILI TEMPORANEE
        { topics: ['while', 'for', 'do-while', 'variabili temporanee'], trace: seed => `Domanda Concettuale: Supponiamo di dover analizzare una serie di dati fino a quando la media supera una soglia. Quale struttura di controllo (tra \`while\`, \`do-while\` o \`for\`) è semanticamente più appropriata se il primo dato deve essere sempre analizzato? Descrivi inoltre due variabili temporanee essenziali per questo compito e come gestisci l'inizializzazione del loro valore all'esterno o all'interno del ciclo per garantire la correttezza della media.`, code_lines: 0 },
        
        // Esercizio 10 (Impossibile - 2 punti): TUTTI, LIMITAZIONE VARIABILI TEMPORANEE/AUSILIARIE
        { topics: ['tutti'], trace: seed => `Scrivi un programma completo che calcola il fattoriale di un numero intero positivo N (es. ${seed % 8 + 3}), ma devi implementare il ciclo di calcolo *senza* dichiarare alcuna variabile ausiliaria (variabile temporanea) oltre al contatore del ciclo e al risultato finale. Questo esercizio mira a testare la comprensione del flusso di controllo e l'uso minimale delle risorse.`, code_lines: 8 }
    ];
    
    // Assegna i punteggi dinamici agli oggetti template
    for (let i = 0; i < exerciseTemplates.length; i++) {
        Object.assign(exerciseTemplates[i], scores[i]);
        exerciseTemplates[i].id = i + 1;
    }


    /**
     * Genera un set unico di 10 esercizi basato sul seed (ID studente).
     * @param {number} studentId
     * @returns {Array<Object>}
     */
    function getStudentExercises(studentId) {
        const seed = studentId * 100 + 1; // Un seed per garantire la variazione
        
        // Mappa il punteggio e genera la traccia finale con il seed specifico
        return exerciseTemplates.map((ex, index) => ({
            id: index + 1,
            P: ex.P, // Punteggio Pratica
            T: ex.T, // Punteggio Teoria
            Total: ex.Total, // Punteggio Totale
            trace: ex.trace(seed + index), // Applica un seed specifico per la traccia
            topics: ex.topics,
            code_lines: ex.code_lines
        }));
    }

    /**
     * Helper per stampare testo con a capo automatico.
     * @param {jsPDF} doc
     * @param {string} text
     * @param {number} x
     * @param {number} y
     * @param {number} maxWidth
     * @param {number} lineHeight
     * @returns {number} La nuova coordinata Y dopo la stampa.
     */
    function printWrappedText(doc, text, x, y, maxWidth, lineHeight) {
        const lines = doc.splitTextToSize(text, maxWidth);
        doc.text(lines, x, y);
        return y + lines.length * lineHeight;
    }

    /**
     * Disegna l'intestazione standard della verifica.
     * @param {jsPDF} doc
     */
    function drawHeader(doc) {
        // --- Intestazione Fissa (Header) ---
        doc.setFont('Inter', 'bold');
        doc.setFontSize(10);
        doc.setTextColor(30, 64, 175); // Blue-800
        doc.text(`Verifica prodotta da Prof. Giuseppe Borzumati - Verifica di Programmazione`, doc.internal.pageSize.getWidth() / 2, 10, { align: 'center' });
        doc.setTextColor(0, 0, 0); // Reset color
        
        // --- Intestazione Dati Studente (Sotto l'Header Fisso) ---
        doc.setFont('Inter', 'normal');
        doc.setFontSize(10);
        const margin = 15;
        const lineSpacing = 8;
        
        // Nome, Cognome, Data (Prima Riga)
        let y_start = 10 + lineSpacing; // Inizia sotto l'header
        doc.text(`Nome: _________________________ Cognome: _________________________ Data: _________________________`, margin, y_start);
        
        // Classe, Indirizzo (Seconda Riga)
        doc.text(`Classe: _________________________ Indirizzo: _________________________`, margin, y_start + lineSpacing);
        
        return y_start + lineSpacing * 2 + 3; // Ritorna Y dopo l'intestazione
    }

    /**
     * Disegna il piè di pagina (Footer).
     * @param {jsPDF} doc
     * @param {number} pageNumber
     * @param {number} totalPages
     */
    function drawFooter(doc, pageNumber, totalPages) {
        doc.setFont('Inter', 'normal');
        doc.setFontSize(8);
        const pageHeight = doc.internal.pageSize.getHeight();
        const pageWidth = doc.internal.pageSize.getWidth();
        const margin = 15;
        
        // Piè di pagina Richiesto (Nome, Cognome, Classe, Data)
        doc.setFontSize(9);
        doc.text(`Nome: _______________ Cognome: _______________ Classe: _______________ Data: _______________`, margin, pageHeight - 10, { align: 'left' });
        
        // Numero di pagina
        doc.text(`Pagina ${pageNumber} di ${totalPages}`, pageWidth - margin, pageHeight - 10, { align: 'right' });
    }

    /**
     * Genera il PDF per un singolo studente.
     * @param {number} studentId
     * @returns {Promise<Blob>}
     */
    async function generatePdf(studentId) {
        const doc = new jsPDF({
            unit: 'mm',
            format: 'a4'
        });
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const margin = 15;
        const textWidth = pageWidth - 2 * margin;
        const lineHeight = 5;
        let y = 0;
        const exercises = getStudentExercises(studentId);
        
        // ======================= SEZIONE A: TRACCE ESERCIZI =======================
        y = drawHeader(doc);
        y += 5;

        // Titolo Sezione A
        doc.setFont('Inter', 'bold');
        doc.setFontSize(14);
        doc.setTextColor(30, 64, 175); // Blue-800
        doc.text(`SEZIONE A: Tracce Esercizi (Punteggio Totale: ${MAX_SCORE})`, pageWidth / 2, y, { align: 'center' });
        doc.setTextColor(0, 0, 0); // Reset color
        y += 8;

        // Loop per gli esercizi
        for (let i = 0; i < exercises.length; i++) {
            const ex = exercises[i];
            
            // Stima dello spazio richiesto (Traccia + Codice + Spazi)
            if (y > pageHeight - 50) {
                drawFooter(doc, doc.internal.pages.length - 1, '?');
                doc.addPage();
                y = drawHeader(doc);
                y += 5;
            }
            
            doc.setFont('Inter', 'bold');
            doc.setFontSize(11);
            doc.setTextColor(4, 120, 87); // Green-600
            doc.text(`Esercizio ${ex.id} (Punti Max: ${ex.Total})`, margin, y);
            y += 5;
            
            doc.setFont('Inter', 'normal');
            doc.setFontSize(10);
            doc.setTextColor(0, 0, 0);
            
            // Stampa della traccia e del blocco di codice
            const traceText = ex.trace;
            const parts = traceText.split('```cpp\n');
            
            // 1. Parte descrittiva prima del codice
            y = printWrappedText(doc, parts[0].trim(), margin, y, textWidth, lineHeight) + 2;

            if (parts.length > 1) {
                // 2. Blocco di codice
                const codeBlock = parts[1].replace('```', '').trim();
                const codeLines = doc.splitTextToSize(codeBlock, textWidth - 4).length;
                const codeHeight = codeLines * 4.5 + 4; // 4.5 è l'interlinea per il codice (più piccolo)
                
                // Salto pagina se il blocco di codice è troppo vicino al fondo
                if (y + codeHeight + 10 > pageHeight - 20) {
                    drawFooter(doc, doc.internal.pages.length - 1, '?');
                    doc.addPage();
                    y = drawHeader(doc);
                    y += 5;
                }
                
                doc.setFont('Inter', 'bold');
                doc.setFontSize(9);
                doc.setFillColor(240, 244, 255); // Light Blue Background
                doc.rect(margin, y, textWidth, codeHeight, 'F');
                
                y = printWrappedText(doc, codeBlock, margin + 2, y + 3, textWidth - 4, 4.5) + 2; // Stampa codice
                doc.setFont('Inter', 'normal'); // Reset font
            }
            
            y += 5; // Spazio tra esercizi
        }

        // --- Finalizzazione Tracce ---
        const totalPagesTraces = doc.internal.pages.length - 1;
        drawFooter(doc, totalPagesTraces, '?');


        // ======================= SEZIONE B: SPIEGAZIONI E GRIGLIA =======================
        doc.addPage();
        y = drawHeader(doc);
        y += 5;

        // Titolo Sezione B
        doc.setFont('Inter', 'bold');
        doc.setFontSize(14);
        doc.setTextColor(190, 18, 60); // Red-700
        doc.text(`SEZIONE B: Giustificazione del Codice e Analisi`, pageWidth / 2, y, { align: 'center' });
        doc.setTextColor(0, 0, 0); // Reset color
        y += 8;

        // Spiegazioni Esercizi (con griglia di attribuzione e linee guida)
        for (let i = 0; i < exercises.length; i++) {
            const ex = exercises[i];
            
            // Stima dello spazio: 20mm per griglia + 20mm per domande + 40mm per righe
            if (y > pageHeight - 90) { 
                drawFooter(doc, doc.internal.pages.length - 1, '?');
                doc.addPage();
                y = drawHeader(doc);
                y += 5;
            }

            // Titolo Esercizio
            doc.setFont('Inter', 'bold');
            doc.setFontSize(11);
            doc.setTextColor(4, 120, 87); // Green-600
            doc.text(`Esercizio ${ex.id}`, margin, y);
            y += 5;
            
            // --- GRIGLIA DI ATTRIBUZIONE DEL PUNTEGGIO ---
            const gridX = margin;
            const gridY = y;
            const gridWidth = textWidth;
            const colWidth = gridWidth / 3;
            const cellHeight = 6;
            
            // Intestazione Griglia
            doc.setFillColor(224, 231, 255); // Blue-100
            doc.rect(gridX, gridY, gridWidth, cellHeight, 'F');
            doc.setFont('Inter', 'bold');
            doc.setFontSize(9);
            doc.setTextColor(30, 64, 175); // Blue-800
            doc.text("Componente", gridX + colWidth * 0.5, gridY + 4, { align: 'center' });
            doc.text("Punteggio Max", gridX + colWidth * 1.5, gridY + 4, { align: 'center' });
            doc.text("Punteggio Ottenuto", gridX + colWidth * 2.5, gridY + 4, { align: 'center' });
            
            // Righe di Contenuto
            doc.setFont('Inter', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(0, 0, 0);
            
            // Riga 1: Pratica (Correttezza del Codice)
            doc.setFillColor(249, 250, 251); // Gray-50
            doc.rect(gridX, gridY + cellHeight, gridWidth, cellHeight, 'F');
            doc.text("Pratica (Correttezza del Codice)", gridX + colWidth * 0.5, gridY + cellHeight + 4, { align: 'center' });
            doc.text(`${ex.P}`, gridX + colWidth * 1.5, gridY + cellHeight + 4, { align: 'center' });
            doc.text("___________", gridX + colWidth * 2.5, gridY + cellHeight + 4, { align: 'center' });

            // Riga 2: Teoria (Spiegazione)
            doc.setFillColor(255, 255, 255); // White
            doc.rect(gridX, gridY + cellHeight * 2, gridWidth, cellHeight, 'F');
            doc.text("Teoria (Spiegazione e Giustificazione)", gridX + colWidth * 0.5, gridY + cellHeight * 2 + 4, { align: 'center' });
            doc.text(`${ex.T}`, gridX + colWidth * 1.5, gridY + cellHeight * 2 + 4, { align: 'center' });
            doc.text("___________", gridX + colWidth * 2.5, gridY + cellHeight * 2 + 4, { align: 'center' });

            // Riga 3: Totale
            doc.setFillColor(224, 231, 255); // Blue-100
            doc.rect(gridX, gridY + cellHeight * 3, gridWidth, cellHeight, 'F');
            doc.setFont('Inter', 'bold');
            doc.text("Totale Esercizio", gridX + colWidth * 0.5, gridY + cellHeight * 3 + 4, { align: 'center' });
            doc.text(`${ex.Total}`, gridX + colWidth * 1.5, gridY + cellHeight * 3 + 4, { align: 'center' });
            doc.text("___________", gridX + colWidth * 2.5, gridY + cellHeight * 3 + 4, { align: 'center' });
            
            // Disegno dei bordi (solo linee verticali)
            doc.setDrawColor(180, 180, 180); // Gray-400
            doc.setLineWidth(0.2);
            for(let j=0; j<=3; j++) doc.line(gridX, gridY + cellHeight * j, gridX + gridWidth, gridY + cellHeight * j); // Linee orizzontali
            
            doc.line(gridX, gridY, gridX, gridY + cellHeight * 4); // Linea sinistra
            doc.line(gridX + colWidth, gridY, gridX + colWidth, gridY + cellHeight * 4); // Colonna 1
            doc.line(gridX + colWidth * 2, gridY, gridX + colWidth * 2, gridY + cellHeight * 4); // Colonna 2
            doc.line(gridX + colWidth * 3, gridY, gridX + colWidth * 3, gridY + cellHeight * 4); // Linea destra

            y = gridY + cellHeight * 4 + 3; // Aggiorna Y dopo la griglia

            // Domande Mirate e Personali
            doc.setFont('Inter', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(75, 85, 99); // Gray-600

            const question1 = `1. Giustificazione Logica (Personale): Quale struttura di controllo (for, while, do-while) hai ritenuto più adatta per questo specifico problema? Fornisci una giustificazione personale sulla sua efficienza rispetto alle alternative, considerando i requisiti di inizializzazione e test.`;
            const question2 = `2. Analisi Critica (Personale): Nello svolgimento di questo esercizio, descrivi il ruolo cruciale di un particolare operatore logico (AND, OR, NOT) o unario (++ / --), o di una variabile temporanea/booleana. Spiega personalmente dove risiedeva la maggiore difficoltà concettuale o il potenziale punto di errore.`;
            
            // Stampa delle domande
            y = printWrappedText(doc, question1, margin, y, textWidth, 4.5) + 1;
            y = printWrappedText(doc, question2, margin, y, textWidth, 4.5) + 3;
            
            // Linee per la Risposta (Codice e Spiegazione)
            doc.setDrawColor(100, 100, 100);
            const numLines = 8; // Ridotte le linee per un layout più pulito
            for (let j = 0; j < numLines; j++) {
                doc.line(margin, y + j * lineHeight, pageWidth - margin, y + j * lineHeight);
            }
            y += numLines * lineHeight + 5;
        }
        
        // --- Finalizzazione Spiegazioni (Aggiorna Totale Pagine) ---
        const totalPagesSections = doc.internal.pages.length - 1;
        drawFooter(doc, totalPagesSections, '?');
        
        
        // ======================= ULTIMA PAGINA: GRIGLIA DI CONVERSIONE =======================
        doc.addPage();
        y = drawHeader(doc);
        y += 5;
        
        // Titolo Griglia (Modificato per rimuovere simboli)
        doc.setFont('Inter', 'bold');
        doc.setFontSize(14);
        doc.setTextColor(153, 27, 27); // Deep Red
        doc.text(`GRIGLIA DI CONVERSIONE PUNTEGGIO FINALE (Max ${MAX_SCORE} a 10)`, pageWidth / 2, y, { align: 'center' });
        doc.setTextColor(0, 0, 0);
        y += 8;

        // Tabella di Conversione (Max 100 -> Voto 10)
        
        // Dati della tabella (Scaling 50 -> 6, 80 -> 8, 100 -> 10)
        const tableX = margin + 30; // Centrata
        const tableY = y + 5;
        const totalTableWidth = pageWidth - 2 * margin - 60;
        const colWidth = totalTableWidth / 2;
        const cellHeight = 10;
        
        // Punteggi per la conversione (Base 100)
        const scoresToConvert = [100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0];
        const grades = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
        
        // Colori Custom
        const headerFill = [191, 219, 254]; // Blue-200
        const headerText = [30, 64, 175];   // Blue-800
        const bodyFill1 = [243, 244, 246];  // Gray-100
        const bodyFill2 = [255, 255, 255];  // White
        
        // Intestazione Tabella
        doc.setFillColor(...headerFill);
        doc.rect(tableX, tableY, totalTableWidth, cellHeight, 'F');
        doc.setFont('Inter', 'bold');
        doc.setTextColor(...headerText);
        doc.text("Punti Ottenuti (Max 100)", tableX + colWidth * 0.5, tableY + 6, { align: 'center' });
        doc.text("Voto Finale (Max 10)", tableX + colWidth * 1.5, tableY + 6, { align: 'center' });
        
        // Righe di Contenuto
        doc.setFont('Inter', 'normal');
        doc.setTextColor(0, 0, 0);
        for (let j = 0; j < scoresToConvert.length; j++) {
            const currentY = tableY + cellHeight * (j + 1);
            const fill = j % 2 === 0 ? bodyFill1 : bodyFill2;
            doc.setFillColor(...fill);
            doc.rect(tableX, currentY, totalTableWidth, cellHeight, 'F');
            
            doc.text(`>= ${scoresToConvert[j]}`, tableX + colWidth * 0.5, currentY + 6, { align: 'center' });
            doc.text(`${grades[j]}`, tableX + colWidth * 1.5, currentY + 6, { align: 'center' });
        }
        
        // Disegno delle Linee (Bordi)
        doc.setDrawColor(209, 213, 219); // Gray-300
        doc.setLineWidth(0.3);
        for (let j = 0; j <= scoresToConvert.length; j++) {
            doc.line(tableX, tableY + cellHeight * j, tableX + totalTableWidth, tableY + cellHeight * j);
        }
        doc.line(tableX, tableY, tableX, tableY + cellHeight * (scoresToConvert.length + 1));
        doc.line(tableX + colWidth, tableY, tableX + colWidth, tableY + cellHeight * (scoresToConvert.length + 1));
        doc.line(tableX + totalTableWidth, tableY, tableX + totalTableWidth, tableY + cellHeight * (scoresToConvert.length + 1));
        
        // Note
        y = tableY + cellHeight * (scoresToConvert.length + 1) + 10;
        doc.setFontSize(10);
        doc.setTextColor(75, 85, 99); // Gray-600
        doc.text('NB: La conversione è a scopo indicativo. Il punteggio finale terrà conto della correttezza concettuale delle spiegazioni.', margin, y);
        
        // --- Finalizzazione Griglia ---
        const totalPagesFinal = doc.internal.pages.length - 1;
        drawFooter(doc, totalPagesFinal, '?');
        
        // Aggiorna i numeri di pagina totali
        const totalPages = doc.internal.pages.length - 1; // Meno la prima pagina vuota
        for (let k = 1; k <= totalPages; k++) {
            doc.setPage(k);
            drawFooter(doc, k, totalPages);
        }

        return doc.output('blob');
    }

    /**
     * Funzione principale per generare e zippare le verifiche.
     */
    async function generateTests() {
        const numAlunni = parseInt(document.getElementById('numAlunni').value);
        const statusMessage = document.getElementById('statusMessage');
        const generateBtn = document.getElementById('generateBtn');

        if (isNaN(numAlunni) || numAlunni < 1) {
            statusMessage.textContent = 'Inserisci un numero valido di alunni (minimo 1).';
            return;
        }

        statusMessage.textContent = 'Inizio generazione...';
        generateBtn.disabled = true;

        const zip = new JSZip();
        
        try {
            for (let i = 1; i <= numAlunni; i++) {
                statusMessage.textContent = `Generazione verifica ${i} di ${numAlunni}...`;
                const pdfBlob = await generatePdf(i);
                zip.file(`Verifica_Programmazione_Alunno_${i}.pdf`, pdfBlob);
            }

            statusMessage.textContent = 'Creazione file ZIP...';
            const content = await zip.generateAsync({ type: "blob" });
            
            // Scarica il file ZIP
            const date = new Date().toISOString().slice(0, 10);
            const filename = `Verifiche_C++_Prof_Borzumati_${date}.zip`;
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(content);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            statusMessage.textContent = `Operazione completata! Scaricato: ${filename}`;

        } catch (error) {
            statusMessage.textContent = `Errore durante la generazione: ${error.message}`;
            console.error("Errore di generazione PDF/ZIP:", error);
        } finally {
            generateBtn.disabled = false;
        }
    }
    
    // Inizializza il font di jsPDF al caricamento
    window.jsPDF = jsPDF;
    jsPDF.autoPrint = false; 

</script>

</body>
</html>
